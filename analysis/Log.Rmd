---
title: "Log"
output:
  workflowr::wflow_html:
              toc: true
              toc_depth: 4
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE)
```


## Nov 16

### Work I did.
For the last week, I re-write the whole pipeline into snakemake files, so that I can run different datasets with ease. [script]

[script]: https://github.com/liliw-w/Trans/tree/main/script

Before listing the results, I will first describe the key steps in the pipeine.

1. Construct co-expressed modules using `minModuleSize=20`.
2. Compute zscores by tensorQTL.
3. Compute pvalues by TruncPCO.
4. Adjust for multiple testing based on one-time permutation, followed by Bonferroni.

### Results summary.

This table is for the results summary.

```{r warning=FALSE}
signals.summary = read.delim("data/signals.summary.txt", check.names = F, stringsAsFactors = F, quote = NULL)
knitr::kable(signals.summary)
```

### TCGA
The following plot is for the 2063 independent signals. The left plot is the histogram of $-logp$. Since signals with $p<10^{-16}$ have pvalue as 0 in R, here I give these signals pvalue of $10^{-17}$, which have $-logp=17$. The plot shows that among 2063 signals, most of them have $p \approx 10^{-5}$. 

**Question**: Is this too small for claiming significance for trans?

The right plot is the histogram of the chromosomes the signals are on.

```{r}
knitr::include_graphics("../data/plot.TCGA.png", error = FALSE)
```


### DGN

As showed in the plot for DGN, among 500 independent signals, most of their pvalues have $p \approx 10^{-5}$.

```{r}
knitr::include_graphics("../data/plot.DGN.png", error = FALSE)
```


### GTEx

1. Expression data pre-process.

Below is how GTEx 2020 paper pre-processs expression data.

"Gene-level expression quantification was performed using RNA-SeQC [68]. Gene-level read counts and TPM values were produced using the following read-level filters: 1) reads were uniquely mapped (corresponding to a mapping quality of 255 for STAR BAMs); 2) reads were aligned in proper pairs; 3) the read alignment distance was ≤ 6; 4) reads were fully contained within exon boundaries. Reads overlapping introns were not counted. These filters were applied using the “-strictMode” flag in RNA-SeQC. Gene expression values for all samples from a given tissue were normalized for eQTL analyses using the following procedure: 1) read counts were normalized between samples using TMM [69]; 2) genes were selected based on expression thresholds of ≥0.1 TPM in ≥20% of samples and ≥6 reads (unnormalized) in ≥20% of samples; 3) expression values for each gene were inverse normal transformed across samples." [link][GTEx 2020 paper supp]

[GTEx 2020 paper supp]: https://science.sciencemag.org/content/sci/suppl/2020/09/09/369.6509.1318.DC1/aaz1776_Aguet_SM.pdf

2. Genotype data pre-process.

Any filter? QCed? script?

## Nov 09

### Paper using permutation-based false discovery rate.

This [paper] uses permutations to correct for FDR of a complex test statistic. Like in our cases, it's unrealistic to do thousands of permutations. Specifically, they did 10 permutations and adjusted pvalues based on these 10 empirical null distributions. They justied why 10 permutations are enough.

[paper]: https://www-nature-com.proxy.uchicago.edu/articles/ng.2756#Sec12

### Modify PCO code from one SNP a time to multiple SNPs.

1. davies method

`davies.R`: Remove `PACKAGE=MPAT`; Run in command line `R SMP SHLIB qfc.cpp`; Run in R `dyn.load("./script/qfc.so")`

2. liumod method

Use liumod method when `p.WI ==0 | p.WI < 0`.

### Snakemake pipeline.

### Results

z (tensorQTL) + p (TruncPCO) + FDR (one time permutation).

z & p: add index for observe data or permutation.

`minModuleSize=20` in WGCNA.

DGN; TCGA

## Nov 02
### Why use `minModuleSize=30` in WGCNA for TCGA?

There are three reasons why I set the minimum number of genes in modules to be 30.

**1. DGN used this setting.**

At first, we looked at the variance explained by the top three PC of each modules under different settings, i.e. `minModuleSize=100, 50, 30`. We found that under setting of 30, the top three PC's explained more variance, so we tended to use 30.

```{r}
knitr::include_graphics("1101.fig1.minModuleSize.png", error = FALSE)
```

The above plots used all 13634 genes without removing any poorly mapped genes. Next, I removed the poorly mapped genes, with 5258 genes left. I used 30 to cluster these 5258 genes and resulted in 18 modules. We then looked at the explained variance and found nothing seemed wrong. So we decided to use 30 for WGCNA and these 18 modules for downstream analysis.

```{r out.height='80%', out.width='80%'}
knitr::include_graphics("1101.fig2.minModuleSize.png", error = FALSE)
```


**2. 30 is the default module size in WGCNA tutorial, and also used by the elife paper.**

[WGCNA tutorial] used 30 as default. ~~The [elife method] also used the default parameters.~~ (Correction: elife method used the default parameters in the R package, where `minClusterSize = 20`.)

[WGCNA tutorial]: https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-02-networkConstr-auto.pdf
[elife method]: https://elifesciences.org/articles/58705#s4

**3. I tried other parameters, e.g. 100. 50, which both increase the unclassified genes.**

```{r}
res = data.frame("minModuleSize" = c(100, 50, 30, 20),
                 "Num.unclassified.genes" = c(5247, 3251, 2908, 2813),
                 "Num.modules" = c(4, 33, 57, 81),
                 "Max.num.genes" = c(1972, 397, 356, 326))
knitr::kable(res)
```


### Look into enrichment of TCGA modules.

Here is the [complete enrichment result].

[complete enrichment result]: https://biit.cs.ut.ee/gplink/l/5R4sgZawQC

#### KEGG pathway enrichment
```{r}
res = read.csv("./data/GO.organizedResult.csv", stringsAsFactors = FALSE)

ind.term = res$source == "KEGG"
term = res[ind.term, -4]

knitr::kable(term, row.names = FALSE)
```


* **ErbB signaling pathway**: "ErbB family members and some of their ligands are often over-expressed, amplified, or mutated in many forms of cancer, making them important therapeutic targets. For example, researchers have found EGFR to be amplified and/or mutated in gliomas and NSCLC while ErbB2 amplifications are seen in breast, ovarian, bladder, NSCLC, as well as several other tumor types. [[source]][source1]

* **Neuroactive ligand-receptor interaction**:
  * Influence on breast cancer MCF-7 cells: "Telocinobufagin might regulate neuroactive ligand-receptor interaction pathway to exert its influences in breast cancer MCF-7 cells." [[source]][source3]
  * Involved in the regulation of renal cell carcinoma. [[source]][source2]
  
* **Mucin type O-glycan biosynthesis**: "Changes in mucin-type O-linked glycosylation are seen in over 90% of breast cancers" [[source]][source4] [[source]][source5]

* **Human papillomavirus infection**: "We demonstrated that HPV is associated with breast cancer development, although the role of HPV in breast cancers is still questionable and further research is required to investigate, in more detail, the role of HPV infection in breast cancer." [[source]][source6]

* **Prolactin signaling pathway**: "elevated PRL levels are correlated with increased breast cancer risk and metastasis" "In vitro studies have indicated a role for PRL in breast cancer proliferation and survival." [[source]][source7]

* **Cocaine addiction**: ???

* **PI3K-Akt signaling pathway**: "PI3K/Akt signaling pathway is key in the development of BC" (breast cancer) [[source]][source8]
  
[source1]: https://www.cellsignal.com/contents/science-cst-pathways-kinase-signaling/erbb-her-signaling/pathways-erbb#:~:text=The%20ErbB%20receptors%20signal%20through,making%20them%20important%20therapeutic%20targets.
[source2]: https://www.karger.com/Article/Pdf/368504
[source3]: https://www-sciencedirect-com.proxy.uchicago.edu/science/article/pii/S0344033818301018
[source4]: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6103458/
[source5]: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1479595/
[source6]: https://bmccancer.biomedcentral.com/articles/10.1186/s12885-019-5286-0#Sec17
[source7]: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5653461/
[source8]: https://link.springer.com/article/10.1007%2Fs10555-010-9261-0



### Debug code for TruncPCO.

I was doubting that TruncPCO (using only $\lambda>1$) code may have bugs because of the following weird qqplot and histogram of pvalues.

```{r out.height='70%', out.width='70%'}
knitr::include_graphics("1101.fig3.TruncPCO.png", error = FALSE)
```

Rows are qqplot and histogram of pvalues. These pvalues are observed pvalues rather than null pvalues. Left column is for standard PCO (using all $\lambda$'s); right is for TruncPCO. I thought TruncPCO is weird because a histogram of pvalues shouldn't be as skewed as the lower right one. This skewed plot means pvalues by TruncPCO are overall smaller than PCO. We thought this may be due to LD among snps, i.e. the tests are not independent. However, even with the LD complication, the histogram should be approximately flat as in the lower left plot, where the tests are not independent either.

So I looked into the code for TruncPCO and see if there are bugs I didn't notice. *(This paragraph explains what the bug is. See the histogram by the debugged code in next paragraph.)* PCO uses the minimum pvalue of six tests as the test statistic, i.e.
$$T_{PCO}=min(p_{PCMinP}, p_{PCFisher}, p_{PCLC}, p_{WI}, p_{Wald}, p_{VC})$$

Then use a inverse normal distribution to calculate pvalue of $T_{PCO}$. So the key step is to compute the six pvalues. The bug happens in the step of computing $p_{WI}$. The test statistic for this pvalus is,
$$T_{WI}=\sum_{k=1}^K {z_k^2} = \sum_{k=1}^K {PC_k^2}=\sum_{k=1}^K {\lambda_k \chi_{1k}^2}$$
,where $K$ is number of all PC's of expression matrix, $PC_k=u_k^Tz \sim N(0, \lambda_k)$, $u_k$ is k-th eigenvector with eigenvalue $\lambda_k$; $z$ is zscore vector for one snp to $K$ genes, $\chi_{1k}$ is chi-square distribution with DF 1. If we only use $\lambda>1$ for TruncPCO, i.e. $T_{WI}^{Trunc}=\sum_{k=1}^{k_0} {PC_k^2}=\sum_{k=1}^{k_0} {\lambda_k \chi_{1k}^2}$, what I only need to do is to subset $\lambda$'s and $PC_k$'s. That is what I did for other five tests. However, in the original PCO package, $T_{WI}$ is calculated using $\sum_{k=1}^K {z_k^2}$ and I should have changed $z_k$'s to $PC_k$'s. But I missed this. So, $T_{WI}$ actually used all $K$ $z_k$'s, and it's larger than the real $T_{WI}^{Trunc}$, therefore the pvalue is smaller than the real $p_{WI}^{Trunc}$. That is why in the above plot, TruncPCO has many small pvalues and its histogram skews to the left.

So I used the debuged code and re-computed pvalues for the same (module, chr). The result is in the third column.

```{r}
knitr::include_graphics("1101.fig4.TruncPCO.png", error = FALSE)
```

The histogram became approximately flat. For this (module13, chr19), there seems to be some signals. Next, I give another example (module, chr), where there seems no signals.

```{r}
knitr::include_graphics("1101.fig5.TruncPCO.png", error = FALSE)
```

The histogram by the debugged TruncPCO is still almost flat in this cese, which makes sense.

Now I have the updated pvalues. Next, I rerun TruncPCO for the null zscore, and use the null p's to adjust for these updated pvalues. Then see how many snps are significant ($p_{adj}<\frac{0.05}{18\times22}$). I do this because I want to see how are the signals by this debugged TruncPCO compared with those by the previous TruncPCO. For now, I checked for the above two (module, chr) and the signals are almost the same.

From now on, I will use this correct version of TruncPCO to compute p's for other datasets and update p's for datasets I've analyzed.

### Use tensorQTL do more permutation?

So far, the way we use to adjust p is to permute samples once, calculate null z, then null p, then using this null p distribution to adjust the observe p's. This one-time permutation procedure should work. We do the permutation once because multiple permutation is computation-time heavy. So can we use tensorQTL to make permutation faster?

As far as I understand, tensorQTL is like FastQTL, which does fast permutation to provide the adjusted minimum pvalues for each gene. This is gene-level adjustment, not the snp-level adjustment as we want. So we can't have more faster permutations by tensorQTL.

### Do another round of permutation.

To see how stable the signals are, I do another round of permutation for the above two (module, chr). Here I use TruncPCO for pvalues and empirical null for p adjustment. The following table gives the results.

```{r}
res = data.frame("example" = c("(module13,chr19)", "(module17,chr15)"),
                 "oldTruncPCO.perm.1" = c(157, 1),
                 "TruncPCO.perm.1" = c(159, 0),
                 "TruncPCO.perm.2" = c(155, 1))
knitr::kable(res)
```



### Notation table

To make it clear, the following table is for notations of different methods.

```{r results='asis'}
res = data.frame("data" = c("observe", "null"),
                 "PCO" = c("p.PCO", "p.null.PCO"),
                 "TruncPCO.old" = c(NA, NA),
                 "TruncPCO" = c("p.TruncPCO", "p.null.TruncPCO"))
knitr::kable(res)
```

* "data" is for the data used. "observe" means pvalues are calculated from the observed data. "null" means pvalues are computed from permutation data. This is needed because we need to adjust pvalues in the downstream FDR analysis using the empirical null distribution of pvalues.
  * We use empirical null because snps are in LD, so the tests are not independent and therefore the null distribution of p is not necessarily uniform.
  * Why not using BH? BH assumes independent tests and uniform null.
  * Why not using Bonferroni? Conservative for snp-level FDR correction, particularly for the trans snp-level FDR.
  * ~~Approaches to deal with the multiple testing in QTL studies, cis and trans. (???)~~
* "PCO" is the standard PCO using all $\lambda$'s. "TruncPCO.old" is PCO using only $\lambda>1$. This is the method used for all results obtained before 11/02/2020. I added ".old" because the code of this TruncPCO has bugs. "TruncPCO" uses the debugded code.

### Signals we have so far.

```{r}
knitr::include_graphics("1101.fig6.signals.png", error = FALSE)
```


