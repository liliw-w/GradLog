---
title: "Log"
output:
  workflowr::wflow_html:
              toc: true
              toc_depth: 4
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE)
```

## Nov 23

Last week, I used three ways to correct for the multiple testing based on the empirical null distributions, including correction based on (1) each module and chromosome pair; (2) combined chromosomes for each module; and (3) combined all chromosomes and modules. For the signals obtained from these three ways, I looked at their pvalues and the chromosomes they are on and found out that the latter two correction ways make more sense. So next I will look at the enrichment of the signals' nearest genes.

Some notes about what I did. I use the signals obtained from the combined chr's and modules. I used all unique signals (rather than independent signals), i.e. 641 signals for DGN and 9196 for TCGA. For each signal, I define its *nearest* gene as the closest gene of which TSS is upstream/downstream 0.5Mbp away from the signal. As a result, there are 50 nearest genes for DGN and 548 for TCGA.

Next, I looked at the enrichment of these genes.

### DGN
Since I am not able to share the link to the complete enrichment result, I posted the 47 genes used by [David][David website link] enrichment tool [here](./converted.DGN.txt) to reproduce the results.

[David website link]: https://david.ncifcrf.gov/

Under BH correction with 0.05 as threshold, there is one significant enrichment cluster: SPRY-domain-related, which includes four genes *BTNL3, BTNL8, BTNL9, TRIM58*.

I doubt that this enrichment happens because some signals are physically close to each other but their nearest genes are different. So I looked at the enrichment of genes that are closest to the independent signals (previously I used all signals). The gene list used by David is [here](./converted.indep.DGN.txt). There is no enriched term under 0.05 BH.


### TCGA
I post the 474 genes used by David enrichment tool [here](./converted.TCGA.txt) to reproduce the results.

Under BH correction with 0.05 as threshold, there are basically two types of enrichment.

1. Guanylate-binding protein

    Relation with cancer: [[source]][Guanylate-binding protein1] [[source]][Guanylate-binding protein2]

[Guanylate-binding protein1]: https://pubmed.ncbi.nlm.nih.gov/29115931/
[Guanylate-binding protein2]: https://www.frontiersin.org/articles/10.3389/fimmu.2019.03139/full
	
2. MHC class II receptor activity/immunity-related: [Antigen processing and presentation], [Rheumatoid arthritis], et al.

[Antigen processing and presentation]: https://onlinelibrary.wiley.com/doi/full/10.1111/imm.12675
[Rheumatoid arthritis]: https://ard.bmj.com/content/79/5/581.abstract

I also tried the independent signals (gene list is [here](./converted.indep.TCGA.txt)). There is no enriched term under 0.05 BH.

### GBAT signals

The following table summarizes the signals from GBAT and whether they are reproduced by our method.

From the Figure 4 of [GBAT paper], there are 5 labeled transcription factors that regulate multiple genes in trans. I checked that if these 5 genes have nearby SNPs that are identified as signals in our analysis (`Regulator.signal`). Then checked the modules the signals correspond to (`signal.module`). Next, I checked whether the TF target genes identified by GBAT (`Target`) are in our modules (`Target.in.module`). If so, check which module these genes are (`Target.module`).

[GBAT paper]: https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02120-1/figures/4Form

The regulator *PLAGL1* is close to the signal 6:144304358, which corresponds to module 11. Only 5 of this regulator's target genes are in our modules and none of them are clustered into module 11.

The regulator *NFE2* is close to the signal 12:54685880, which corresponds to module 1 and module 11. Among the 6 target genes, 2 are in our modules. One is in module1, the other one is in module 5.

The regulator *NFKBIA* is close to the signal 14:35602108, which corresponds to module 11. Among the 3 target genes, one is in our modules and it is in module 11.

The regulator *IKZF1* is close to multiple signals, which are introns of *IKZF1*. The signals correspond to multiple modules including 1,2,5,6,7,8,11,18. Among the regulator's 4 target genes, one is in our modules and it is in module 18.

The regulator *SENP7* is not close to any signals.

```{r warning=FALSE}
res = read.delim("data/GBAT.txt", check.names = F, stringsAsFactors = F, quote = NULL)
res[is.na(res)] = " "
knitr::kable(res)
```

### Look at some top signals

I looked at part of the top signals with very small pvalues. The following table summarizes the signals' postions, the corresponding modules, pvalues, the signal's nearest gene, and the gene info. The first two rows give the signals that are near two TFs, *IKZF1, KLF2*.

Notes: Some pvalues are zero because they are smaller than the numerical precision ($<10^{-16}$).

```{r warning=FALSE}
res = read.delim("data/top.signals.txt", check.names = F, stringsAsFactors = F, quote = NULL)
res[is.na(res)] = " "
knitr::kable(res)
```


## Nov 16

### Work I did.
For the last week, I re-write the whole pipeline into snakemake files, so that I can run different datasets with ease. [script]

[script]: https://github.com/liliw-w/Trans/tree/main/script

Before listing the results, I will first describe the key steps in the pipeine.

1. Construct co-expressed modules using `minModuleSize=20`.
2. Compute zscores by tensorQTL.
3. Compute pvalues by TruncPCO.
4. Adjust for multiple testing based on one-time permutation, followed by Bonferroni.

### Results summary.

This table is for the results summary.

```{r warning=FALSE}
signals.summary = read.delim("data/signals.summary.txt", check.names = F, stringsAsFactors = F, quote = NULL)
signals.summary[is.na(signals.summary)] = " "
knitr::kable(signals.summary)
```

### TCGA

The following three plots are for FDR correction based on each module and chr pair; combined chr's for each module; combined chr's and modules.

The first plot is for the 2063 independent signals. The left plot is the histogram of $-logp$. Since signals with $p<10^{-16}$ have pvalue as 0 in R, here I give these signals pvalue of $10^{-17}$, which have $-logp=17$. The plot shows that among 2063 signals, most of them have $p \approx 10^{-5}$. 

**Question**: Is this too small for claiming significance for trans?

The right plot is the histogram of the chromosomes the signals are on.

```{r fig.cap="(module, chr) pair"}
knitr::include_graphics("plot.TCGA.png", error = FALSE)
```

```{r fig.cap="combine chr"}
knitr::include_graphics("plotchr.TCGA.png", error = FALSE)
```

```{r fig.cap="combine chr and modules"}
knitr::include_graphics("plotchr.module.TCGA.png", error = FALSE)
```


### DGN

The following three plots are for FDR correction based on each module and chr pair; combined chr's for each module; combined chr's and modules.

As showed in the plot for DGN, among 500 independent signals, most of their pvalues have $p \approx 10^{-5}$.

```{r fig.cap="(module, chr) pair"}
knitr::include_graphics("plot.DGN.png", error = FALSE)
```

```{r fig.cap="combine chr"}
knitr::include_graphics("plotchr.DGN.png", error = FALSE)
```

```{r fig.cap="combine chr and modules"}
knitr::include_graphics("plotchr.module.DGN.png", error = FALSE)
```


### GTEx

1. Expression data pre-process.

Below is how GTEx 2020 paper pre-processs expression data.

"Gene-level expression quantification was performed using RNA-SeQC [68]. Gene-level read counts and TPM values were produced using the following read-level filters: 1) reads were uniquely mapped (corresponding to a mapping quality of 255 for STAR BAMs); 2) reads were aligned in proper pairs; 3) the read alignment distance was ≤ 6; 4) reads were fully contained within exon boundaries. Reads overlapping introns were not counted. These filters were applied using the “-strictMode” flag in RNA-SeQC. Gene expression values for all samples from a given tissue were normalized for eQTL analyses using the following procedure: 1) read counts were normalized between samples using TMM [69]; 2) genes were selected based on expression thresholds of ≥0.1 TPM in ≥20% of samples and ≥6 reads (unnormalized) in ≥20% of samples; 3) expression values for each gene were inverse normal transformed across samples." [source][GTEx 2020 paper supp]

[GTEx 2020 paper supp]: https://science.sciencemag.org/content/sci/suppl/2020/09/09/369.6509.1318.DC1/aaz1776_Aguet_SM.pdf

2. Genotype data pre-process.

Any filter? QCed? script?

## Nov 09

### Paper using permutation-based false discovery rate.

This [paper] uses permutations to correct for FDR of a complex test statistic. Like in our cases, it's unrealistic to do thousands of permutations. Specifically, they did 10 permutations and adjusted pvalues based on these 10 empirical null distributions. They justied why 10 permutations are enough.

[paper]: https://www-nature-com.proxy.uchicago.edu/articles/ng.2756#Sec12

### Modify PCO code from one SNP a time to multiple SNPs.

1. davies method

`davies.R`: Remove `PACKAGE=MPAT`; Run in command line `R SMP SHLIB qfc.cpp`; Run in R `dyn.load("./script/qfc.so")`

2. liumod method

Use liumod method when `p.WI ==0 | p.WI < 0`.

### Snakemake pipeline.

### Results

z (tensorQTL) + p (TruncPCO) + FDR (one time permutation).

z & p: add index for observe data or permutation.

`minModuleSize=20` in WGCNA.

DGN; TCGA

## Nov 02
### Why use `minModuleSize=30` in WGCNA for TCGA?

There are three reasons why I set the minimum number of genes in modules to be 30.

**1. DGN used this setting.**

At first, we looked at the variance explained by the top three PC of each modules under different settings, i.e. `minModuleSize=100, 50, 30`. We found that under setting of 30, the top three PC's explained more variance, so we tended to use 30.

```{r}
knitr::include_graphics("1101.fig1.minModuleSize.png", error = FALSE)
```

The above plots used all 13634 genes without removing any poorly mapped genes. Next, I removed the poorly mapped genes, with 5258 genes left. I used 30 to cluster these 5258 genes and resulted in 18 modules. We then looked at the explained variance and found nothing seemed wrong. So we decided to use 30 for WGCNA and these 18 modules for downstream analysis.

```{r out.height='80%', out.width='80%'}
knitr::include_graphics("1101.fig2.minModuleSize.png", error = FALSE)
```


**2. 30 is the default module size in WGCNA tutorial, and also used by the elife paper.**

[WGCNA tutorial] used 30 as default. ~~The [elife method] also used the default parameters.~~ (Correction: elife method used the default parameters in the R package, where `minClusterSize = 20`.)

[WGCNA tutorial]: https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-02-networkConstr-auto.pdf
[elife method]: https://elifesciences.org/articles/58705#s4

**3. I tried other parameters, e.g. 100. 50, which both increase the unclassified genes.**

```{r}
res = data.frame("minModuleSize" = c(100, 50, 30, 20),
                 "Num.unclassified.genes" = c(5247, 3251, 2908, 2813),
                 "Num.modules" = c(4, 33, 57, 81),
                 "Max.num.genes" = c(1972, 397, 356, 326))
knitr::kable(res)
```


### Look into enrichment of TCGA modules.

Here is the [complete enrichment result].

[complete enrichment result]: https://biit.cs.ut.ee/gplink/l/5R4sgZawQC

#### KEGG pathway enrichment
```{r}
res = read.csv("./data/GO.organizedResult.csv", stringsAsFactors = FALSE)

ind.term = res$source == "KEGG"
term = res[ind.term, -4]

knitr::kable(term, row.names = FALSE)
```


* **ErbB signaling pathway**: "ErbB family members and some of their ligands are often over-expressed, amplified, or mutated in many forms of cancer, making them important therapeutic targets. For example, researchers have found EGFR to be amplified and/or mutated in gliomas and NSCLC while ErbB2 amplifications are seen in breast, ovarian, bladder, NSCLC, as well as several other tumor types. [[source]][source1]

* **Neuroactive ligand-receptor interaction**:
  * Influence on breast cancer MCF-7 cells: "Telocinobufagin might regulate neuroactive ligand-receptor interaction pathway to exert its influences in breast cancer MCF-7 cells." [[source]][source3]
  * Involved in the regulation of renal cell carcinoma. [[source]][source2]
  
* **Mucin type O-glycan biosynthesis**: "Changes in mucin-type O-linked glycosylation are seen in over 90% of breast cancers" [[source]][source4] [[source]][source5]

* **Human papillomavirus infection**: "We demonstrated that HPV is associated with breast cancer development, although the role of HPV in breast cancers is still questionable and further research is required to investigate, in more detail, the role of HPV infection in breast cancer." [[source]][source6]

* **Prolactin signaling pathway**: "elevated PRL levels are correlated with increased breast cancer risk and metastasis" "In vitro studies have indicated a role for PRL in breast cancer proliferation and survival." [[source]][source7]

* **Cocaine addiction**: ???

* **PI3K-Akt signaling pathway**: "PI3K/Akt signaling pathway is key in the development of BC" (breast cancer) [[source]][source8]
  
[source1]: https://www.cellsignal.com/contents/science-cst-pathways-kinase-signaling/erbb-her-signaling/pathways-erbb#:~:text=The%20ErbB%20receptors%20signal%20through,making%20them%20important%20therapeutic%20targets.
[source2]: https://www.karger.com/Article/Pdf/368504
[source3]: https://www-sciencedirect-com.proxy.uchicago.edu/science/article/pii/S0344033818301018
[source4]: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6103458/
[source5]: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1479595/
[source6]: https://bmccancer.biomedcentral.com/articles/10.1186/s12885-019-5286-0#Sec17
[source7]: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5653461/
[source8]: https://link.springer.com/article/10.1007%2Fs10555-010-9261-0



### Debug code for TruncPCO.

I was doubting that TruncPCO (using only $\lambda>1$) code may have bugs because of the following weird qqplot and histogram of pvalues.

```{r out.height='70%', out.width='70%'}
knitr::include_graphics("1101.fig3.TruncPCO.png", error = FALSE)
```

Rows are qqplot and histogram of pvalues. These pvalues are observed pvalues rather than null pvalues. Left column is for standard PCO (using all $\lambda$'s); right is for TruncPCO. I thought TruncPCO is weird because a histogram of pvalues shouldn't be as skewed as the lower right one. This skewed plot means pvalues by TruncPCO are overall smaller than PCO. We thought this may be due to LD among snps, i.e. the tests are not independent. However, even with the LD complication, the histogram should be approximately flat as in the lower left plot, where the tests are not independent either.

So I looked into the code for TruncPCO and see if there are bugs I didn't notice. *(This paragraph explains what the bug is. See the histogram by the debugged code in next paragraph.)* PCO uses the minimum pvalue of six tests as the test statistic, i.e.
$$T_{PCO}=min(p_{PCMinP}, p_{PCFisher}, p_{PCLC}, p_{WI}, p_{Wald}, p_{VC})$$

Then use a inverse normal distribution to calculate pvalue of $T_{PCO}$. So the key step is to compute the six pvalues. The bug happens in the step of computing $p_{WI}$. The test statistic for this pvalus is,
$$T_{WI}=\sum_{k=1}^K {z_k^2} = \sum_{k=1}^K {PC_k^2}=\sum_{k=1}^K {\lambda_k \chi_{1k}^2}$$
,where $K$ is number of all PC's of expression matrix, $PC_k=u_k^Tz \sim N(0, \lambda_k)$, $u_k$ is k-th eigenvector with eigenvalue $\lambda_k$; $z$ is zscore vector for one snp to $K$ genes, $\chi_{1k}$ is chi-square distribution with DF 1. If we only use $\lambda>1$ for TruncPCO, i.e. $T_{WI}^{Trunc}=\sum_{k=1}^{k_0} {PC_k^2}=\sum_{k=1}^{k_0} {\lambda_k \chi_{1k}^2}$, what I only need to do is to subset $\lambda$'s and $PC_k$'s. That is what I did for other five tests. However, in the original PCO package, $T_{WI}$ is calculated using $\sum_{k=1}^K {z_k^2}$ and I should have changed $z_k$'s to $PC_k$'s. But I missed this. So, $T_{WI}$ actually used all $K$ $z_k$'s, and it's larger than the real $T_{WI}^{Trunc}$, therefore the pvalue is smaller than the real $p_{WI}^{Trunc}$. That is why in the above plot, TruncPCO has many small pvalues and its histogram skews to the left.

So I used the debuged code and re-computed pvalues for the same (module, chr). The result is in the third column.

```{r}
knitr::include_graphics("1101.fig4.TruncPCO.png", error = FALSE)
```

The histogram became approximately flat. For this (module13, chr19), there seems to be some signals. Next, I give another example (module, chr), where there seems no signals.

```{r}
knitr::include_graphics("1101.fig5.TruncPCO.png", error = FALSE)
```

The histogram by the debugged TruncPCO is still almost flat in this cese, which makes sense.

Now I have the updated pvalues. Next, I rerun TruncPCO for the null zscore, and use the null p's to adjust for these updated pvalues. Then see how many snps are significant ($p_{adj}<\frac{0.05}{18\times22}$). I do this because I want to see how are the signals by this debugged TruncPCO compared with those by the previous TruncPCO. For now, I checked for the above two (module, chr) and the signals are almost the same.

From now on, I will use this correct version of TruncPCO to compute p's for other datasets and update p's for datasets I've analyzed.

### Use tensorQTL do more permutation?

So far, the way we use to adjust p is to permute samples once, calculate null z, then null p, then using this null p distribution to adjust the observe p's. This one-time permutation procedure should work. We do the permutation once because multiple permutation is computation-time heavy. So can we use tensorQTL to make permutation faster?

As far as I understand, tensorQTL is like FastQTL, which does fast permutation to provide the adjusted minimum pvalues for each gene. This is gene-level adjustment, not the snp-level adjustment as we want. So we can't have more faster permutations by tensorQTL.

### Do another round of permutation.

To see how stable the signals are, I do another round of permutation for the above two (module, chr). Here I use TruncPCO for pvalues and empirical null for p adjustment. The following table gives the results.

```{r}
res = data.frame("example" = c("(module13,chr19)", "(module17,chr15)"),
                 "oldTruncPCO.perm.1" = c(157, 1),
                 "TruncPCO.perm.1" = c(159, 0),
                 "TruncPCO.perm.2" = c(155, 1))
knitr::kable(res)
```



### Notation table

To make it clear, the following table is for notations of different methods.

```{r results='asis'}
res = data.frame("data" = c("observe", "null"),
                 "PCO" = c("p.PCO", "p.null.PCO"),
                 "TruncPCO.old" = c(NA, NA),
                 "TruncPCO" = c("p.TruncPCO", "p.null.TruncPCO"))
knitr::kable(res)
```

* "data" is for the data used. "observe" means pvalues are calculated from the observed data. "null" means pvalues are computed from permutation data. This is needed because we need to adjust pvalues in the downstream FDR analysis using the empirical null distribution of pvalues.
  * We use empirical null because snps are in LD, so the tests are not independent and therefore the null distribution of p is not necessarily uniform.
  * Why not using BH? BH assumes independent tests and uniform null.
  * Why not using Bonferroni? Conservative for snp-level FDR correction, particularly for the trans snp-level FDR.
  * ~~Approaches to deal with the multiple testing in QTL studies, cis and trans. (???)~~
* "PCO" is the standard PCO using all $\lambda$'s. "TruncPCO.old" is PCO using only $\lambda>1$. This is the method used for all results obtained before 11/02/2020. I added ".old" because the code of this TruncPCO has bugs. "TruncPCO" uses the debugded code.

### Signals we have so far.

```{r}
knitr::include_graphics("1101.fig6.signals.png", error = FALSE)
```


